Сегодня мы разберём `частицы`.Они очень популярны и могут быть использованы для достижения различных эффектов, таких как звезды, дым, дождь, пыль, огонь и многое другое.

Преимущество частиц в том, что вы можете отображать сотни тысяч частиц на экране с разумной частотой кадров.

Создавать `частицы` так же просто, как создать `mesh`. Нам нужна [BufferGeometry](https://threejs.org/docs/#api/en/core/BufferGeometry), `материал`, который может обрабатывать частицы ([PointsMaterial](https://threejs.org/docs/#api/en/materials/PointsMaterial)), и вместо создания `mesh` нам нужно создать [points](https://threejs.org/docs/#api/en/objects/Points).

## Particles

Мы можем использовать любую из основных геометрий в `three.js`. По тем же причинам, что и для `mesh`, предпочтительнее использовать `bufferGeometry`. Каждая вершина геометрии станет частицей:

```javascript
/**
 * Particles
 */
// Geometry
const particlesGeometry = new THREE.SphereGeometry(1, 32, 32);
```

## [PointsMaterial](https://threejs.org/docs/#api/en/materials/PointsMaterial)

Нам нужен особый тип материала, который называется `PointsMaterial`. Этот материал уже может многое,возможно позже мы разберём как создавать свой материал из частиц.

`PointsMaterial` обладает множеством свойств, специфичных для частиц, таких как `size` для управления всеми размерами частиц и `sizeAttenuation` для указания, должны ли удаленные частицы быть меньше частиц, расположенных ближе к камере:

```javascript
// Material
const particlesMaterial = new THREE.PointsMaterial({
  size: 0.02,
  sizeAttenuation: true,
});
```

Как всегда, мы также можем изменить эти свойства после создания материала:

```javascript
const particlesMaterial = new THREE.PointsMaterial();
particlesMaterial.size = 0.02;
particlesMaterial.sizeAttenuation = true;
```

## Points

Наконец, мы можем создать частицы так же, как мы создаем `mesh`, но с использованием класса `Points`. Не забудьте добавить это в сцену:

```javascript
// Points
const particles = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particles);
```

Очень просто и красиво.Не так ли?

А теперь мы их настроим.

## Custom geometry

Чтобы создать `Custom geometry`, мы можем начать с `BufferGeometry` и добавить атрибут `position`. Замените `SphereGeometry` пользовательской геометрией и добавьте атрибут `position`, как мы делали раньше:

```javascript
// Geometry
const particlesGeometry = new THREE.BufferGeometry();
const count = 500;

const positions = new Float32Array(count * 3); // Умножаем на 3 так как каждая позиция состоит из 3 значений (x, y, z)

for (
  let i = 0;
  i < count * 3;
  i++ // Умножаем на 3 по той же причине
) {
  positions[i] = (Math.random() - 0.5) * 10; // Math.random() - 0,5, чтобы иметь случайное значение от -0,5 до +0,5
}

particlesGeometry.setAttribute(
  "position",
  new THREE.BufferAttribute(positions, 3)
); // Создаём атрибут Three.js BufferAttribute и указываем, что каждая информация состоит из 3 значений.
```

На самом деле этот код сможет создать не каждый, так что не грустим, если вы не можете извлечь этот код самостоятельно. Это немного сложно, и переменные используют странные форматы.

Вы должны получить кучу частиц по всей сцене. Сейчас самое время повеселиться и проверить возможности вашего компьютера. Попробуй поставить любые числа. У вас могут быть миллионы частиц и при этом сохраняться приемлемая частота кадров.

Вы можете представить, что существуют пределы. На слабом компьютере или смартфоне вы не сможете воспроизводить миллионы частиц со скоростью 60 кадров в секунду. Мы также собираемся добавить эффекты, которые значительно уменьшат частоту кадров. Но все равно, это довольно впечатляюще.

На данный момент, давайте сохраним количество на 5000 и изменим размер на 0.1:

```javascript

```

## Color, map и alpha map

Мы можем изменить цвет всех частиц в `PointMaterial`. Не забываем! Что вам нужно использовать класс `Color`, если вы меняете это свойство после создания экземпляра материала:

```javascript
particlesMaterial.color = new THREE.Color("#ff88cc");
```

Мы также можем использовать map свойство для нанесения текстуры на эти частицы.Для этого используем `TextureLoader` работает также как и `gltfLoader`, которым мы пользовались ранеe. Сейчас мы можем загрузить свои текстуры:

```javascript
/**
 * Textures
 */
const textureLoader = new THREE.TextureLoader();
const particleTexture = textureLoader.load("some/folder/path");

// ...

particlesMaterial.map = particleTexture;
```

Также вы можете создавать свои собственные текстуры.

Если вы присмотритесь, то увидите, что передние частицы скрывают задние частицы. Нам нужно активировать `transparent` (прозрачность) и использовать текстуру в `alphaMap`. Эти свойства есть и в блендере для рендера и других интересных моментов.

```javascript
// particlesMaterial.map = particleTexture
particlesMaterial.transparent = true;
particlesMaterial.alphaMap = particleTexture;
```

Это потому, что частицы рисуются в том же порядке, в каком они были созданы, и `WebGL` на самом деле не знает, какая из них находится перед другой.

Есть несколько способов исправить это.

## Используем AlphaTest

`alphaTest` - это значение между 0 и 1, которое позволяет `WebGL` определять, когда не следует отображать пиксель в соответствии с прозрачностью этого пикселя. По умолчанию значение равно 0, что означает, что пиксель будет отображен в любом случае. Если мы используем небольшое значение, такое как 0.001, пиксель не будет отображаться, если альфа равна 0:

```javascript
particlesMaterial.alphaTest = 0.001;
```

Это решение не идеально, и мы всё ещё можем увидеть сбои.

```javascript

```

## Используем depthTest

При рисовании `WebGL` проверяет, находится ли то, что рисуется, ближе, чем то, что уже нарисовано. Это называется глубинным тестированием и может быть деактивировано (закоментим `alphaTest` и посмотрим):

```javascript
// particlesMaterial.alphaTest = 0.001
particlesMaterial.depthTest = false;
```

Хотя это решение, кажется, полностью устраняет нашу проблему, отключение тестирования глубины может привести к ошибкам, если в вашей сцене есть другие объекты или частицы другого цвета. Частицы могут быть нарисованы так, как если бы они находились над остальной частью сцены.

Добавьте куб к сцене, чтобы увидеть, что:

```javascript
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshBasicMaterial()
);
scene.add(cube);
```

## Используем depthWrite

Как мы уже говорили, `WebGL` проверяет, является ли то, что рисуется, ближе, чем то, что уже нарисовано. Глубина того, что рисуется, хранится в том, что мы называем `depth buffer`. Вместо того, чтобы не проверять, находится ли частица ближе, чем в этом буфере глубины, мы можем сказать `WebGL` не записывать частицы в этот буфер глубины:

```javascript
// particlesMaterial.alphaTest = 0.001
// particlesMaterial.depthTest = false
particlesMaterial.depthWrite = false;
```

В нашем случае это решение устранит проблему практически без недостатков.Мы видели множество методов, и идеального решения не существует. Вам придется адаптироваться и найти лучшую комбинацию в соответствии с проектом.

## Blending

В настоящее время `WebGL` рисует пиксели один поверх другого.

Изменяя `blending`, мы можем указать `WebGL` не только отрисовывать пиксель, но и добавлять цвет этого пикселя к цвету уже отрисованного пикселя.Трудно объяснить, надеюсь получилось. Это даст эффект насыщения, который может выглядеть потрясающе.

Чтобы проверить это, просто измените `blending` на `THREE.AdditiveBlending` (сохраните `depthWrite`):

```javascript
// particlesMaterial.alphaTest = 0.001
// particlesMaterial.depthTest = false
particlesMaterial.depthWrite = false;
particlesMaterial.blending = THREE.AdditiveBlending;
```

Но будьте осторожны, этот эффект повлияет на производительность.

## Different colors

У нас может быть разный цвет для каждой частицы. Сначала нам нужно добавить новый атрибут `color`, как мы сделали для позиции. Цвет состоит из красного, зеленого и синего (3 значения), поэтому код будет очень похож на `position`. На самом деле мы можем использовать один и тот же цикл для этих двух атрибутов:

```javascript
const positions = new Float32Array(count * 3);
const colors = new Float32Array(count * 3);

for (let i = 0; i < count * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 10;
  colors[i] = Math.random();
}

particlesGeometry.setAttribute(
  "position",
  new THREE.BufferAttribute(positions, 3)
);
particlesGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
```

Будьте осторожны с единственными и множественными числами.

Чтобы активировать эти цвета вершин, просто измените `vertexColors` свойство на true:

```javascript
particlesMaterial.vertexColors = true;
```

Основной цвет материала по-прежнему влияет на эти цвета вершин. Не боимся изменять этот цвет или даже комментировать его.

```javascript
// particlesMaterial.color = new THREE.Color('#ff88cc')
```

Также мы можем их анимировать. Существует много способов, давайте разберём пару из них.

## Используем Points как object

```javascript
const tick = () => {
  const elapsedTime = clock.getElapsedTime();

  // Update particles
  particles.rotation.y = elapsedTime * 0.2;

  // ...
};
```

Хотя это уже круто, мы хотим больше контроля над каждой частицей.

## Изменение атрибутов

Мы собираемся анимировать частицы так, как если бы они плавали по волнам, но сначала давайте посмотрим, как мы можем обновить вершины.

Начните с комментария предыдущей анимации.

Мы хотим, чтобы вершины перемещались только вверх и вниз, что означает, что мы собираемся обновить только y ось. Поскольку `position` представляет собой одномерный массив, мы должны просмотреть его и обновить только второе значение, которое является `y` координатой.

Давайте начнем с прохождения каждой вершины:

```javascript
const tick = () => {
  // ...

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
  }

  // ...
};
```

Здесь мы выбрали простой `for` цикл, который идет от `0` к `count`, и мы создали `i3` переменную внутри, которая имеет размер 3 на 3, просто умножив `i `на 3.

Самый простой способ имитировать движение волн - использовать простой синус. Во-первых, мы собираемся обновить все вершины, чтобы они поднимались и опускались с одинаковой частотой.

`y` Координаты может быть доступна в массиве по индексу `i3 + 1`:

```javascript
const tick = () => {
  // ...

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;

    particlesGeometry.attributes.position.array[i3 + 1] = Math.sin(elapsedTime);
  }

  // ...
};
```

К сожалению, ничего не движется. Проблема в том, что `Three.js` должен быть уведомлен о том, что геометрия изменилась. Чтобы сделать это, мы должны установить `needsUpdate ` на `true` для `position`, как только мы закончим обновление вершин:

```javascript
const tick = () => {
  // ...

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;

    particlesGeometry.attributes.position.array[i3 + 1] = Math.sin(elapsedTime);
  }
  particlesGeometry.attributes.position.needsUpdate = true;

  // ...
};
```

Все частицы должны двигаться вверх и вниз, как плоскость.

Это хорошее начало, и мы почти на месте. Все, что нам нужно сделать сейчас, это применить смещение к синусу между частицами, чтобы мы получили эту форму волны.

Для этого мы можем использовать `x` координату. И чтобы получить это значение, мы можем использовать ту же технику, которую мы использовали для `y` координаты, но вместо `i3 + 1`, это просто `i3`:

```javascript
const tick = () => {
  // ...

  for (let i = 0; i < count; i++) {
    let i3 = i * 3;

    const x = particlesGeometry.attributes.position.array[i3];
    particlesGeometry.attributes.position.array[i3 + 1] = Math.sin(
      elapsedTime + x
    );
  }
  particlesGeometry.attributes.position.needsUpdate = true;

  // ...
};
```

Вы должны получить красивые волны частиц.

## C помощью пользовательского шейдера

Чтобы обновить эти миллионы частиц в каждом кадре с хорошей частотой кадров, нам нужно создать наш собственный материал с нашими собственными шейдерами.