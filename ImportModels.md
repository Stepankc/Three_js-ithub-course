Для этого урока модели можно взять отсюда https://github.com/KhronosGroup/glTF-Sample-Models

## Formats

# `GLTF`

`GLTF` стал очень популярным в последние несколько лет.

Он поддерживает очень разные наборы данных. Очевидно, что у вас могут быть такие данные, как геометрия и материалы, но у вас также могут быть такие данные, как камеры, освещение, анимация, скелеты и даже несколько сцен.

Он также поддерживает различные форматы файлов, такие как `json`, двоичные и встроенные текстуры.

`GLTF` стал стандартом, когда дело доходит до реального времени. И поскольку это становится стандартом, большинство 3D-программ, игровых движков и библиотек поддерживают его. Это означает, что вы можете легко получить аналогичный результат в разных средах.

Это не означает, что вы должны использовать `GLTF` во всех случаях. Если вам просто нужна геометрия, вам лучше использовать другой формат, такой как `OBJ`, `FBX`, `STL` или `PLY`. Вы должны протестировать разные форматы в каждом проекте, чтобы увидеть, есть ли у вас все необходимые данные, не слишком ли тяжелый файл, сколько времени требуется для распаковки информации, если она сжата, и т.д.

У `GLTF` также есть различные форматы

- `GLTF`. Этот формат является своего рода форматом по умолчанию.Есть несколько файлов к каждому существует доступ

- `glTF-Binary`. Этот формат может быть немного легче и удобнее для загрузки, потому что есть только один файл, но вы не сможете легко изменить его данные.

- `GLTF-Draco`. Этот формат похож на формат `glTF` по умолчанию, но данные (обычно геометрия) сжимаются с использованием алгоритма `Draco`. Если вы сравните размер .bin файла, вы увидите, что он намного легче.

- `GLTF-Embedded`. Этот файл на самом деле является `JSON`, который вы можете открыть в своем редакторе. Единственным преимуществом этого формата является наличие только одного легко редактируемого файла.

## Import модели в three.js

Для загрузки файлов `GLTF` в `Three.js` , мы должны использовать GLTFLoader. Этот класс недоступен по умолчанию в `THREE`

```javascript
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
```

затем добавляем экземпляр:

```javascript
/**
 * Models
 */
const gltfLoader = new GLTFLoader();
```

Чтобы загрузить модели,мы вызываем метод `load(...)` и используем правильные параметры:

```javascript
gltfLoader.load("/models/Duck/glTF/Duck.gltf", (gltf) => {
  console.log(gltf);
});
```

## Добавляем модель на нашу сцену

Если вы посмотрите на объект в консоли, вы найдете много элементов. Наиболее важной частью является свойство `scene`, потому что у нас есть только одна сцена в экспортируемой модели. Всегда начинайте с изучения того, что доступно в нем, и следите за `scale` различных `object3D`

Сейчас нашим `mesh` должна являться утка.Мы не обращаем внимание на остальное. Самое главное что для `scale` установлено минимальное значение.

Все, что мы хотим, это включить нашу утку в сцену. У нас есть множество способов сделать это:

- Добавить всё что есть в нашу сцену.
- Добавить дочерние элементы `scene` в нашу сцену и игнорировать неиспользуемую перспективную камеру.
- Отфильтровать дочерние элементы перед добавлением в сцену, чтобы удалить ненужные объекты,например, такие как `PerspectiveCamera`.
- Добавьте только `mesh`, но в итоге мы получим утку, которая может быть неправильно расположена на сцене.

Тк структура очень простая мы добавим `Object3D` и проигнорим встроенную камеру.

```javascript
gltfLoader.load("/models/Duck/glTF/Duck.gltf", (gltf) => {
  scene.add(gltf.scene.children[0]);
});
```

В папке доступна другая модель с именем `FlightHelmet`.

Попробуем загрузить эту модель:

```javascript
gltfLoader.load("/models/FlightHelmet/glTF/FlightHelmet.gltf", (gltf) => {
  scene.add(gltf.scene.children[0]);
});
```

Вместо красивого шлема мы получаем всего несколько деталей.

Проблема в том, что мы добавили только первый дочерний элемент.

Что мы можем попробовать, так это зациклить дочерние элементы и добавить их в сцену:

```javascript
for (const child of gltf.scene.children) {
  scene.add(child);
}
```

Это приведет к появлению большего количества элементов, но не всех из них. Что еще хуже, при обновлении вы можете получить разные детали.

Проблема в том, что когда мы добавляем дочерний элемент из одной сцены в другую, он автоматически удаляется из первой сцены.

Когда мы добавляем первый объект, он удаляется из первой сцены, а второй сцене элемент просто перемещается на первое место. Но ваш цикл теперь принимает второй элемент массива. У вас всегда будут элементы, оставшиеся в `children` массиве.

Чтобы исправить это мы возьмём первые дочерние элементы загруженной сцены и добавим их в нашу сцену, пока их не останется:

```javascript
while (gltf.scene.children.length) {
  scene.add(gltf.scene.children[0]);
}
```

И сейчас мы получили шлем, со всеми деталями. Но есть 1 проблема, при таком использование мы можем не выйти из нашего цикла и убить всю страницу. Давайте воспользуемся методом из `javascript` для дублирования массива. Для этого мы можем использовать `spread ...` и поместить результат в совершенно новый массив `[]`:

```javascript
const children = [...gltf.scene.children];
for (const child of children) {
  scene.add(child);
}
```

Наконец, одно хорошее и простое решение, о котором мы упоминали ранее, - добавить свойство `scene`:

```javascript
scene.add(gltf.scene);
```

## Анимация

`glTF` также поддерживает анимацию. И `Three.js` может обрабатывать эти анимации.

Для начала нам нужна анимированная модель, она есть в папке public. Давайте изменим путь для загрузки:

```javascript
gltfLoader.load("/models/Fox/glTF/Fox.gltf");
```

У нас появилась проблема; лиса слишком большая.

Перед обработкой анимации давайте исправим масштаб.Лиса состоит из одного объекта 3D, который сам сделан из `Bone` и `SkinnedMesh`. Можете загуглить что это,но идея в том, что мы не должны просто масштабировать `Object3D`. Если здесь это может сработать, то на более сложных обьектах всё сломается

Мы можем маштабировать её при загрузке в нашу сцену:

```javascript
gltfLoader.load("/models/Fox/glTF/Fox.gltf", (gltf) => {
  gltf.scene.scale.set(0.025, 0.025, 0.025);
  scene.add(gltf.scene);
});
```

## Работа с анимациями

Если вы посмотрите на загруженный `gltf` объект, вы можете увидеть свойство `animations`, содержащее [AnimationClip](https://threejs.org/docs/#api/en/animation/AnimationClip).
Для того чтобы их использовать мы должны создать [AnimationMixer](https://threejs.org/docs/#api/en/animation/AnimationMixer).`AnimationMixer` подобен проигрывателю, связанному с объектом, который может содержать неограниченное кол-во анимаций.

Давайте создадим `mixer` и отправим параметр `gltf.scene`:

```javascript
const mixer = new THREE.AnimationMixer(gltf.scene);
```

Теперь с помощью `clipAction(...)` добавим наши анимации:

```javascript
const action = mixer.clipAction(gltf.animations[0]);
```

И мы, наконец, можем вызвать `play()`:

```javascript
action.play();
```

К сожалению, анимации по-прежнему нет.

Чтобы воспроизвести анимацию, мы должны указать микшеру обновлять себя в каждом кадре.

Проблема в том, что наша переменная `mixer` была объявлена в функции обратного вызова `load`, и у нас нет доступа к ней в функции `tick`. Чтобы исправить это, мы можем объявить `mixer` со значением null вне функции и обновлять ее при загрузке модели:

```javascript
let mixer = null;

gltfLoader.load("/models/Fox/glTF/Fox.gltf", (gltf) => {
  gltf.scene.scale.set(0.03, 0.03, 0.03);
  scene.add(gltf.scene);

  mixer = new THREE.AnimationMixer(gltf.scene);
  const action = mixer.clipAction(gltf.animations[0]);
  action.play();
});
```

Теперь обновим микшер в функции `tick` с нашим `deltatime`, сначала проверяем переменную `mixer`

```javascript
const tick = () => {
  // ...

  if (mixer) {
    mixer.update(deltaTime);
  }

  // ...
};
```

## Three.js редактор

`Three.js` обладает собственным онлайн-редактором. [redactor](https://threejs.org/editor)

Это похоже на программное обеспечение для 3D, но онлайн и с меньшим количеством функций. Вы можете создавать примитивы, источники света, материалы и т. Д.
