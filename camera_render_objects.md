# Материалы для чтения

- [документация Threejs](https://threejs.org/docs/index.html#manual/ru/introduction/Creating-a-scene)
- [книга по threejs](https://discoverthreejs.com/)

## Создание сцены (Scene)

Пришло время создать нашу сцену и показать что-то на экране.

Для начала нам нужны 4 элемента:

- Сцена, которая будет содержать объекты
- Некоторые объекты
- Камера
- Средство визуализации

Сцена похожа на контейнер. Вы размещаете свои объекты, модели, частицы, источники света в нем, и в какой-то момент вы спрашиваете Three.js чтобы отрисовать эту сцену.

Чтобы создать сцену, используйте класс Scene:

```javascript
// Scene
const scene = new THREE.Scene();
```

## Объекты (Objects)

Объектами могут быть почти любые вещи. У вас могут быть импортированные модели, частицы, источники света.

Мы начнем с простого красного кубика.

Чтобы создать этот красный куб, нам нужно создать тип объекта с именем Mesh. Mesh - это комбинация геометрии и материала.

Существует множество геометрий и материалов, но пока мы будем придерживаться простоты и создадим Box Geometry и MeshBasicMaterial.

Чтобы создать геометрию, мы используем класс Box Geometry с первыми 3 параметрами, которые соответствуют размеру коробки.

```javascript
const geometry = new THREE.BoxGeometry(1, 1, 1);
```

Для создания материала мы используем класс MeshBasicMaterial с одним параметром: object {}, содержащий все параметры. Все, что нам нужно, это указать его свойство color.

указание цвета работает также как в обычном js,также вы можете отправить экземпляр класса Color — подробнее об этом мы расскажем позже.

```javascript
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
```

Чтобы создать финальный Mesh, мы используем класс Mesh и отправляем геометрию и материал в качестве параметров.

```javascript
// Object
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
const mesh = new THREE.Mesh(geometry, material);
```

теперь мы можем добавить объект в сцену используя `add()`

```javascript
scene.add(mesh);
```

## Камера

Существуют различные типы камер, и мы поговорим о них в следующем уроке. На данный момент нам просто нужна камера, которая обрабатывает перспективу (делая близкие объекты более заметными, чем удаленные объекты).

У вас может быть несколько камер, как на съемочной площадке, и вы можете переключаться между этими камерами по своему усмотрению. Обычно используют только одну камеру

Чтобы создать камеру, мы используем класс PerspectiveCamera.

Есть два важных параметра, которые мы должны обеспечить.

### The field of view (Поле зрения)

`The field of view` - это то, насколько велик ваш угол обзора. Если вы используете очень большой угол, вы сможете видеть во всех направлениях сразу, но с большим искажением, потому что результат будет нарисован на маленьком прямоугольнике. Если вы используете небольшой угол обзора, все будет выглядеть увеличенным. `The field of view` (или fov) выражается в градусах и соответствует вертикальному углу обзора. Для этого упражнения мы будем использовать угол в 75 градусов.

### The aspect ratio

В большинстве случаев соотношение сторон представляет собой ширину деленную на его высоту. На данный момент мы ничего не указали, сделаем это позже. А сейчас мы создадим объект с значениями, которые мы сможем использовать повторно.

Важно добавить свою камеру к сцене. Все будет работать без добавления камеры к сцене, но дальше это может привести к ошибкам:

```javascript
// Sizes
const sizes = {
  width: 800,
  height: 600,
};
// Camera
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
scene.add(camera);
```

## Рендер

Создайте элемент `<canvas>` перед загрузкой скриптов и присвоите ему класс:

```HTML
<canvas class="webgl"></canvas>
```

Чтобы отрендерить, мы используем класс `WebGL Renderer` с одним параметром: объект {}, содержащий все параметры. Нам нужно найти `canvas` через js

для этого используйте `document.querySelector(...)`

Нам также необходимо обновить размер вашего рендера с помощью метода `setSize(...)`, используя объект sizes, который мы создали ранее. Метод `setSize(...)` автоматически изменит размер нашего `<canvas>` соответствующим образом:

```javascript
// Canvas
const canvas = document.querySelector("canvas.webgl");

// Renderer
const renderer = new THREE.WebGLRenderer({
  canvas: canvas,
});
renderer.setSize(sizes.width, sizes.height);
```

## Первый рендер

Теперь давайте отрендерим сцену.Для этого вызовите метод render(...) и отправьте ему сцену и камеру в качестве параметров:

```javascript
renderer.render(scene, camera);
```

Все еще doesnt work? Вот в чем проблема: мы не указали положение ни вашего объекта, ни нашей камеры. Оба находятся в положении по умолчанию, которое является центром сцены, и мы не можем видеть объект изнутри (по умолчанию).

Подсказка: нам нужно что-то двигать.

Чтобы сделать это, у нас есть доступ к нескольким свойствам каждого объекта, таким как положение, поворот и масштаб. На данный момент используйте свойство `position` для перемещения камеры назад.

`Свойство position` - это объект с тремя соответствующими свойствами: x, y и z. По умолчанию, `Three.js` считает ось вперед/назад равной z.

Чтобы переместить камеру назад, нам нужно присвоить этому свойству положительное значение. Вы можете сделать это в любом месте, как только создадите переменную camera, но это должно произойти до того, как вы выполните рендеринг:

```javascript
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
camera.position.z = 3;
scene.add(camera);
```

## canvas на весь экран

Чтобы `canvas` идеально помещался в окне, вместо использования фиксированных чисел в переменной sizes мы используем window.innerWidth и window.innerHeight:

```javascript
// Sizes
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight,
};
```

теперь мы можем увидеть что canvas на всё окно, но у нас всё ещё остался скролл и белое поле, это связано со стилями браузера, которые установлены по умолчанию
чтобы исправить это, мы будем использовать `scss`, для этого создаем файл с расширением `scss` и импортируем его в js:

```javascript
import "./index.scss";

//.....
```

в `scss` мы убираем padding и margin для всего:

```scss
* {
  margin: 0;
  padding: 0;
}

body,
html {
  overflow: hidden;
}
```

также для canvas с классом webgl фиксим позицию:

```scss
.webgl {
  position: fixed;
  top: 0;
  left: 0;
}
```

у некоторых может появиться синий контур, его можно убрать добавив в `webgl`

```scss
.webgl {
  outline: none;
}
```

## Transform object

Прежде чем анимировать нашу сцену, нам нужно знать, как преобразовывать объекты в нашей сцене. Мы уже сделали это с камерой, переместив ее назад, используя camera.position.z = 3.

Есть 4 свойства для преобразования объектов в нашей сцене

### перемещение объектов

у позиции есть 3 свойства x,y,z. Это 3 необходимые оси для позиционирования чего-либо в трехмерном пространстве.

```javascript
mesh.position.x = 0.7;
mesh.position.y = -0.6;
mesh.position.z = 1;
```

Чтобы изменить значения, вместо изменения x, y и z по отдельности, вы также можете использовать метод set(...):

```javascript
mesh.position.set(1, 1, 1);
```

### Axes helper

Прежде чем мы двинемся дальше, как вы видите, позиционирование вещей в пространстве может быть настоящей проблемой. Знать, куда ориентирована каждая ось, сложно, особенно когда мы начинаем двигать камеру.
Одним из хороших решений является использование `Three.js AxesHelper`.

AxesHelper отобразит 3 линии, соответствующие осям x, y и z, каждая из которых начинается в центре сцены и идет в соответствующем направлении.

```javascript
/**
 * Axes Helper
 */
const axesHelper = new THREE.AxesHelper(2);
scene.add(axesHelper);
```

### Scale objects

```javascript
mesh.scale.x = 2;
mesh.scale.y = 0.25;
mesh.scale.z = 0.5;
```

### Rotate objects

Свойство вращения также имеет свойства x, y и z, но вместо Vector3 это Эйлер. Когда вы меняете свойства x, y и z Эйлера, вы изменяете положение оси x,y,z и куб вращается по другому

Значение этих осей выражается в радианах. Если вы хотите получить половину оборота, вам придется написать что-то вроде 3,14159 (число pi)

```javascript
mesh.rotation.x = Math.PI * 0.25;
mesh.rotation.y = Math.PI * 0.25;
```

### Look at this

Экземпляры Object3D имеют отличный метод `lookAt(...)`, который позволяет вам попросить объект посмотреть на что-то. Объект автоматически повернет свою ось -z в направлении указанной вами цели. Нет необходимости в сложной математике.

Вы можете использовать его, чтобы повернуть камеру к объекту или переместить глаза персонажа на объект.

Параметр является целью и должен быть Vector3. Вы можете создать его, просто чтобы попробовать:

```javascript
camera.lookAt(new THREE.Vector3(0, -1, 0));
```

Куб кажется выше, но на самом деле камера смотрит под куб.

Мы также можем использовать любой существующий Vector3, такой как положение меша, но это приведет к положению камеры по умолчанию, потому что наш меш находится в центре сцены.

```javascript
camera.lookAt(mesh.position);
```
